{
    "componentChunkName": "component---src-templates-page-tsx",
    "path": "/patterns/polymorphic",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"name\": \"Polymorphism\",\n  \"route\": \"/patterns/polymorphic'\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"polymorphism\"\n  }, \"Polymorphism\"), mdx(\"h2\", {\n    \"id\": \"as-prop\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"as\"), \" prop\"), mdx(\"p\", null, \"With the polymorphic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" prop you can replace the DOM element that will be\\nrendered. This is necessary when you need to change the element to meet a\\nsemantic need, or provide a different interaction.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"NOTE: Usage of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" prop is a new pattern still being adopted in the Design System and therefore is not yet fully supported on all components. If you have an immediate need for component polymorphism please reach out to the Design System team so we can expedite the conversion process for your needs.\")), mdx(\"h3\", {\n    \"id\": \"using-a-polymorphic-component\"\n  }, \"Using a polymorphic component\"), mdx(\"p\", null, \"One common use case for component polymorphism is to provide a more semantically\\nmeaningful HTML element. Say for example a component that renders using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"div\"), \"\\nelement by default but a more semantically meaningful element(like a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nav\"), \" el)\\nis preferred. This need can easily be accomplished using the following approach.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"noRender startExpanded\",\n    \"noRender\": true,\n    \"startExpanded\": true\n  }, \"import { PolymorphicDivComponent } from 'some/psds/component/path'\\nimport { PolymorphicButton } from 'some/other/psds/component/path'\\nimport { Link } from 'some/routing-library'\\n\\nrender(\\n  <>\\n    {/* NOTE: The components default behavior is to render a `div` element. */}\\n    <PolymorphicDivComponent />\\n\\n    {/* NOTE: Using the `as` prop, you can change the component to render using\\n      *       a different HTMLElement that is more semantically meaningful.\\n      */}\\n    <PolymorphicDivComponent as=\\\"footer\\\" />\\n    <PolymorphicDivComponent as=\\\"header\\\" />\\n    <PolymorphicDivComponent as=\\\"nav\\\" />\\n    <PolymorphicDivComponent as=\\\"section\\\" />\\n\\n    {/* NOTE: Using the as prop for changing Button components based on semantic\\n      *       need is also a common use case for polymorphism\\n      */}\\n    <PolymorphicButton as=\\\"a\\\" />\\n    <PolymorphicButton as=\\\"button\\\" />\\n\\n    {/* NOTE: The `as` prop can also be used to replace the rendering element\\n      *       with a new React Element. This can be used to achieve greater\\n      *       component composition and can help when integrating with external\\n      *       libraries.\\n      */}\\n    <PolymorphicButton as={Link} />\\n  </>\\n)\\n\")), mdx(\"h3\", {\n    \"id\": \"usage-with-styled-components\"\n  }, \"Usage with styled-components\"), mdx(\"p\", null, \"The Design System polymorphic approach is designed to work with\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"styled-components\"), \". You should be able to compose and style any Design System\\ncomponents that support polymorphism using the common \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"styled-components\"), \" api\\npatterns.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Official \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://styled-components.com/docs/api#as-polymorphic-prop\"\n  }, \"styled-component polymorphic docs\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"noRender startExpanded\",\n    \"noRender\": true,\n    \"startExpanded\": true\n  }, \"import styled from \\\"styled-components\\\";\\nimport { PolymorphicButton } from 'some/other/psds/component/path'\\n\\nconst StyledButton = styled(PolymorphicButton)`\\n  color: red;\\n`;\\n\\nrender(\\n  <>\\n    <StyledButton />\\n    <StyledButton as=\\\"a\\\" />\\n    <StyledButton as=\\\"span\\\" />\\n  </>\\n)\\n\")), mdx(\"h3\", {\n    \"id\": \"usage-with-emotion\"\n  }, \"Usage with Emotion\"), mdx(\"p\", null, \"The Design System polymorphic approach is also designed to work with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"emotion\"), \".\\nYou should be able to compose and style any Design System components that\\nsupports polymorphism using the common \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"emotion\"), \" api patterns.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Official \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://emotion.sh/docs/styled#as-prop\"\n  }, \"emotion polymorphic docs\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"noRender startExpanded\",\n    \"noRender\": true,\n    \"startExpanded\": true\n  }, \"import emotion from \\\"@emotion/styled\\\";\\nimport { PolymorphicButton } from 'some/other/psds/component/path'\\n\\n/* NOTE: I've had some issues with the emotion typings to fully support our\\n *       polymorphic `as` typings. Below is the approach I've found works the\\n *       best and avoids type errors - although it's not as clean or as helpful\\n *       with its introspections as the styled-component examples. I'm not as\\n *       experienced with emotion as i would like to be...so if anyone reading\\n *       this has a better approach please inform the Design System team or open\\n *       an issue on github.\\n *\\n *       - danethurber 03/25/2021\\n */\\nconst BaseStyledButton = emotion(\\\"button\\\")`\\n  color: hotpink;\\n`;\\nconst StyledButton = React.forwardRef<HTMLButtonElement, any>((props, ref) => (\\n  <BaseStyledButton as={PolymorphicButton} ref={ref} {...props} />\\n));\\n\\nrender(\\n  <>\\n    <StyledButton />\\n    <StyledButton as=\\\"a\\\" />\\n    <StyledButton as=\\\"span\\\" />\\n  </>\\n)\\n\")), mdx(\"h2\", {\n    \"id\": \"creating-a-polymorphic-component\"\n  }, \"Creating a polymorphic component\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"utils\"), \" package of the design system exports a genericized higher order\\nfunction that you can use to replace the native \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.forwardRef\"), \". Using the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forwardRefWithAs\"), \" utility will provide you with greater type introspection of\\nthe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \", native props/attribute typings, and will include typings for the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" props.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"noRender startExpanded\",\n    \"noRender\": true,\n    \"startExpanded\": true\n  }, \"import { forwardRefWithAs } from '@pluralsight/ps-design-system-util'\\n\\nconst Button = forwardRefWithAs<Props, 'button'>((props, ref) => {\\n  const { as: Comp = 'button', ...rest } = props\\n  return <Comp ref={ref} {...rest} />\\n})\\n\")), mdx(\"p\", null, \"If you need to use it with a render prop function it's straightforward.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"noRender startExpanded\",\n    \"noRender\": true,\n    \"startExpanded\": true\n  }, \"import { forwardRefWithAs } from '@pluralsight/ps-design-system-util'\\n\\ninterface Props {\\n  children?: React.ReactNode | (() => JSX.Element);\\n}\\n\\nconst TestInput = forwardRefWithAs<Props, \\\"input\\\">((props, ref) => {\\n  const { as: Comp = \\\"input\\\", children, ...rest } = props;\\n  return (\\n    <Comp ref={ref} {...rest}> {isFunction(children) ? children() : children} </Comp>\\n  );\\n});\\n\\n\")), mdx(\"p\", null, \"If you need a component that also support static properties (like for instance\\nyou are using the compound components pattern) we provide a higher order\\nfunction to create typesafe components with typed static properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"noRender startExpanded\",\n    \"noRender\": true,\n    \"startExpanded\": true\n  }, \"import { forwardRefWithAsAndStatics } from '@pluralsight/ps-design-system-util'\\n\\nconst Nested: React.FC = props => <div {...props} />\\n\\ninterface Statics {\\n  Nested: typeof Nested\\n}\\n\\nconst Compound = forwardRefWithAsAndStatics<unknown, 'div', Statics>(\\n  (props, ref) => {\\n    const { as: Comp = 'div', ...rest } = props\\n    return <Comp ref={ref} {...rest} />\\n  }\\n)\\nCompound.Nested = Nested\\n\")), mdx(\"p\", null, \"In the case you need to memoize a component, there is also a utility function\\nthat can be used to replace the functionality of the core \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.memo\"), \" function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"noRender startExpanded\",\n    \"noRender\": true,\n    \"startExpanded\": true\n  }, \"import { forwardRefWithAs, memoWithAs } from '@pluralsight/ps-design-system-util'\\n\\nconst ButtonImpl = forwardRefWithAs<Props, 'button'>((props, ref) => {\\n  const { as: Comp = 'button', ...rest } = props\\n  return <Comp ref={ref} {...rest} />\\n})\\n\\nconst Button = memoWithAs(ButtonImpl)\\n\\nrender(\\n  <>\\n    <Button />\\n    <Button as=\\\"a\\\" />\\n  </>\\n)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"name":"Polymorphism","route":"/patterns/polymorphic'"},"headings":[{"value":"Polymorphism","depth":1},{"value":"as prop","depth":2},{"value":"Using a polymorphic component","depth":3},{"value":"Usage with styled-components","depth":3},{"value":"Usage with Emotion","depth":3},{"value":"Creating a polymorphic component","depth":2}]}},"pageContext":{"slug":"/patterns/polymorphic/","version":"CHANGELOG"}},
    "staticQueryHashes": []}